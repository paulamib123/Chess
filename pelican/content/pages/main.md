Title: Driver Code

This is the main script of the program
It has the following functions:

#### **1. setup()**

~~~python
def setup():
    squares = [y + x for x in '12345678' for y in 'ABCDEFGH']
    board_view = dict(zip(squares, START))
    piece_view = {_: [] for _ in 'BKNPQRbknpqr'}
    for square in squares:
        piece = board_view[square]
        if piece != SPACE:
            piece_view[piece].append(square)
    return board_view, piece_view
~~~

The setup function is used to generate the board view and the piece view.

##### **Output Example:-**

**Board View**

_{'A1': 'R', 'B1': 'N', 'C1': 'B', 'D1': 'Q', 'E1': 'K', 'F1': 'B', 'G1': 'N', 'H1': 'R', 'A2': 'P', 'B2': 'P', 'C2': 'P', 'D2': 'P', 'E2': 'P', 'F2': 'P', 'G2': 'P', 'H2': 'P', 'A3': ' ', 'B3': ' ', 'C3': ' ', 'D3': ' ', 'E3': ' ', 'F3': ' ', 'G3': ' ', 'H3': ' ', 'A4': ' ', 'B4': ' ', 'C4': ' ', 'D4': ' ', 'E4': ' ', 'F4': ' ', 'G4': ' ', 'H4': ' ', 'A5': ' ', 'B5': ' ', 'C5': ' ', 'D5': ' ', 'E5': ' ', 'F5': ' ', 'G5': ' ', 'H5': ' ', 'A6': ' ', 'B6': ' ', 'C6': ' ', 'D6': ' ', 'E6': ' ', 'F6': ' ', 'G6': ' ', 'H6': ' ', 'A7': 'p', 'B7': 'p', 'C7': 'p', 'D7': 'p', 'E7': 'p', 'F7': 'p', 'G7': 'p', 'H7': 'p', 'A8': 'r', 'B8': 'n', 'C8': 'b', 'D8': 'q', 'E8': 'k', 'F8': 'b', 'G8': 'n', 'H8': 'r'}_

**Piece View**

_{'B': ['C1', 'F1'], 'K': ['E1'], 'N': ['B1', 'G1'], 'P': ['A2', 'B2', 'C2', 'D2', 'E2', 'F2', 'G2', 'H2'], 'Q': ['D1'], 'R': ['A1', 'H1'], 'b': ['C8', 'F8'], 'k': ['E8'], 'n': ['B8', 'G8'], 'p': ['A7', 'B7', 'C7', 'D7', 'E7', 'F7', 'G7', 'H7'], 'q': ['D8'], 'r': ['A8', 'H8']}_

#### **2. make_one_move()**

~~~python
def make_one_move(move, board_view, piece_view):
    if move[0] in "Pp":
        return pawn.make_pawn_move(move, board_view, piece_view)
    if "Oo" in move:
        return pieces.castle(move, board_view, piece_view)
    return pieces.move_piece(move, board_view, piece_view)
~~~

This function first checks if a move starts with the letter "P" or "p". If it starts with a "P" or "p" it makes a pawn move by calling the function make_pawn_move().

Next it checks if a move has "O" or "o" in it i.e if it is a castling move. If it is a castling move then it performs the castle by calling the castle() function.

If it does not satisfy any of the conditions above then it means it is a piece move and it calls the function move_piece() and makes the piece move.

#### **3. display_position()**

~~~python
def display_position(b):
    print(b)
~~~

This function prints the current board view.

#### **4. make_moves()**

~~~python
def make_moves(pgnfile, MOVE_BY_MOVE = False):
    if not os.path.exists(pgnfile):
        print(f'PGN File {pgnfile} not found')
        exit(1)
    board_view, piece_view = setup()

    moves = pgnparser.pgn_to_moves(pgnfile)
    for wmove, bmove in moves[:-1]:
        board_view, piece_view = make_one_move(wmove, board_view, piece_view)
        board_view, piece_view = make_one_move(bmove, board_view, piece_view)
        if MOVE_BY_MOVE:
            display_position(board_view)

    wmove, bmove = moves[-1]
    board_view, piece_view = make_one_move(wmove, board_view, piece_view)
    if len(bmove) > 0:
        board_view, piece_view = make_one_move(bmove, board_view, piece_view)
    display_position(board_view)
    exit(0)
~~~

This function loops through the list of tuples of the moves generated by parsing the pgn file and gets the white move and the black move seperately and makes a single move first using the white move and then another single move by using the black move with the help of the make_one_move() function and displays the final board view.


